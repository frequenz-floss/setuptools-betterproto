{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Betterproto Setuptools plugin","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A modern <code>setuptools</code> plugin to generate Python files from proto files using <code>betterproto</code>.</p> <p>This plugin is based on <code>repo-config</code>'s <code>grpc_tools</code> plugin.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"#similar-projects","title":"Similar projects","text":"<ul> <li><code>setuptools-proto</code>: We didn't use this project because it seems a bit inactive and not widely used. It also seems to need some configuration as code, which we wanted to avoid.</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing to Betterproto Setuptools plugin","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>setuptools_betterproto</li> </ul>"},{"location":"reference/setuptools_betterproto/","title":"setuptools_betterproto","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto","title":"setuptools_betterproto","text":"<p>A modern setuptools plugin to generate Python files from proto files using betterproto.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto-classes","title":"Classes","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto","title":"setuptools_betterproto.CompileProto","text":"<p>             Bases: <code>Command</code></p> <p>Build the Python protobuf files.</p> Source code in <code>src/setuptools_betterproto/_command.py</code> <pre><code>class CompileProto(setuptools.Command):\n\"\"\"Build the Python protobuf files.\"\"\"\nproto_path: str\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\nproto_glob: str\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\ninclude_paths: str\n\"\"\"Comma-separated list of paths to include when compiling the protobuf files.\"\"\"\nout_dir: str\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\ndescription: str = \"compile protobuf files using betterproto\"\n\"\"\"Description of the command.\"\"\"\nuser_options: list[tuple[str, str | None, str]] = [\n(\n\"proto-path=\",\nNone,\n\"path of the root directory containing the protobuf files\",\n),\n(\"proto-glob=\", None, \"glob pattern to use to find the protobuf files\"),\n(\n\"include-paths=\",\nNone,\n\"comma-separated list of paths to include when compiling the protobuf files\",\n),\n(\n\"out-dir=\",\nNone,\n\"path of the root directory where the Python files will be generated\",\n),\n]\n\"\"\"Options of the command.\"\"\"\ndef initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nconfig = _config.ProtobufConfig.from_pyproject_toml()\nself.proto_path = config.proto_path\nself.proto_glob = config.proto_glob\nself.include_paths = \",\".join(config.include_paths)\nself.out_dir = config.out_dir\ndef finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\ndef run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\ninclude_paths = list(map(pathlib.Path, self.include_paths.split(\",\")))\nproto_path = pathlib.Path(self.proto_path)\nproto_files = [\np.relative_to(proto_path) for p in proto_path.rglob(self.proto_glob)\n]\nif not proto_files:\nprint(\nf\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n\"skipping compilation of proto files.\"\n)\nreturn\nprotoc_cmd = [\nsys.executable,\n\"-m\",\n\"grpc_tools.protoc\",\n*(f\"-I{p}\" for p in [self.proto_path, *include_paths]),\nf\"--python_betterproto_out={self.out_dir}\",\n*map(str, proto_files),\n]\nprint(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\nsubprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto-attributes","title":"Attributes","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = (\n\"compile protobuf files using betterproto\"\n)\n</code></pre> <p>Description of the command.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.include_paths","title":"include_paths  <code>instance-attribute</code>","text":"<pre><code>include_paths: str\n</code></pre> <p>Comma-separated list of paths to include when compiling the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.out_dir","title":"out_dir  <code>instance-attribute</code>","text":"<pre><code>out_dir: str\n</code></pre> <p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.proto_glob","title":"proto_glob  <code>instance-attribute</code>","text":"<pre><code>proto_glob: str\n</code></pre> <p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.proto_path","title":"proto_path  <code>instance-attribute</code>","text":"<pre><code>proto_path: str\n</code></pre> <p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.user_options","title":"user_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_options: list[tuple[str, str | None, str]] = [\n(\n\"proto-path=\",\nNone,\n\"path of the root directory containing the protobuf files\",\n),\n(\n\"proto-glob=\",\nNone,\n\"glob pattern to use to find the protobuf files\",\n),\n(\n\"include-paths=\",\nNone,\n\"comma-separated list of paths to include when compiling the protobuf files\",\n),\n(\n\"out-dir=\",\nNone,\n\"path of the root directory where the Python files will be generated\",\n),\n]\n</code></pre> <p>Options of the command.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto-functions","title":"Functions","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.finalize_options","title":"finalize_options","text":"<pre><code>finalize_options() -&gt; None\n</code></pre> <p>Finalize options.</p> Source code in <code>src/setuptools_betterproto/_command.py</code> <pre><code>def finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.initialize_options","title":"initialize_options","text":"<pre><code>initialize_options() -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>src/setuptools_betterproto/_command.py</code> <pre><code>def initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nconfig = _config.ProtobufConfig.from_pyproject_toml()\nself.proto_path = config.proto_path\nself.proto_glob = config.proto_glob\nself.include_paths = \",\".join(config.include_paths)\nself.out_dir = config.out_dir\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Compile the Python protobuf files.</p> Source code in <code>src/setuptools_betterproto/_command.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\ninclude_paths = list(map(pathlib.Path, self.include_paths.split(\",\")))\nproto_path = pathlib.Path(self.proto_path)\nproto_files = [\np.relative_to(proto_path) for p in proto_path.rglob(self.proto_glob)\n]\nif not proto_files:\nprint(\nf\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n\"skipping compilation of proto files.\"\n)\nreturn\nprotoc_cmd = [\nsys.executable,\n\"-m\",\n\"grpc_tools.protoc\",\n*(f\"-I{p}\" for p in [self.proto_path, *include_paths]),\nf\"--python_betterproto_out={self.out_dir}\",\n*map(str, proto_files),\n]\nprint(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\nsubprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig","title":"setuptools_betterproto.ProtobufConfig  <code>dataclass</code>","text":"<p>A configuration for the protobuf files.</p> <p>The configuration can be loaded from the <code>pyproject.toml</code> file using the class method <code>from_pyproject_toml()</code>.</p> Source code in <code>src/setuptools_betterproto/_config.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ProtobufConfig:\n\"\"\"A configuration for the protobuf files.\n    The configuration can be loaded from the `pyproject.toml` file using the class\n    method `from_pyproject_toml()`.\n    \"\"\"\nproto_path: str = \".\"\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\nproto_glob: str = \"*.proto\"\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\ninclude_paths: Sequence[str] = ()\n\"\"\"The paths to add to the include path when compiling the protobuf files.\"\"\"\nout_dir: str = \".\"\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\n@classmethod\ndef from_pyproject_toml(\ncls, path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n        The options are read from the `[tool.frequenz-repo-config.protobuf]`\n        section of the `pyproject.toml` file.\n        Args:\n            path: The path to the `pyproject.toml` file.\n            **defaults: The default values for the options missing in the file.  If\n                a default is missing too, then the default in this class will be used.\n        Returns:\n            The configuration.\n        \"\"\"\ntry:\nwith open(path, \"rb\") as toml_file:\npyproject_toml = tomllib.load(toml_file)\nexcept FileNotFoundError:\nreturn cls(**defaults)\nexcept OSError as err:\n_logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\nreturn cls(**defaults)\ntry:\nconfig = pyproject_toml[\"tool\"][\"setuptools_betterproto\"]\nexcept KeyError:\nreturn cls(**defaults)\ndefault = cls(**defaults)\nknown_keys = frozenset(dataclasses.asdict(default).keys())\nconfig_keys = frozenset(config.keys())\nif unknown_keys := config_keys - known_keys:\n_logger.warning(\n\"WARNING: There are some configuration keys in pyproject.toml we don't \"\n\"know about and will be ignored: %s\",\n\", \".join(f\"'{k}'\" for k in unknown_keys),\n)\nattrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\nreturn dataclasses.replace(default, **attrs)\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig-attributes","title":"Attributes","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.include_paths","title":"include_paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>include_paths: Sequence[str] = ()\n</code></pre> <p>The paths to add to the include path when compiling the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.out_dir","title":"out_dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>out_dir: str = '.'\n</code></pre> <p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.proto_glob","title":"proto_glob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proto_glob: str = '*.proto'\n</code></pre> <p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.proto_path","title":"proto_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proto_path: str = '.'\n</code></pre> <p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig-functions","title":"Functions","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.from_pyproject_toml","title":"from_pyproject_toml  <code>classmethod</code>","text":"<pre><code>from_pyproject_toml(\npath: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self\n</code></pre> <p>Create a new configuration by loading the options from a <code>pyproject.toml</code> file.</p> <p>The options are read from the <code>[tool.frequenz-repo-config.protobuf]</code> section of the <code>pyproject.toml</code> file.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to the <code>pyproject.toml</code> file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pyproject.toml'</code> </p> <code>**defaults</code> <p>The default values for the options missing in the file.  If a default is missing too, then the default in this class will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The configuration.</p> Source code in <code>src/setuptools_betterproto/_config.py</code> <pre><code>@classmethod\ndef from_pyproject_toml(\ncls, path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n    The options are read from the `[tool.frequenz-repo-config.protobuf]`\n    section of the `pyproject.toml` file.\n    Args:\n        path: The path to the `pyproject.toml` file.\n        **defaults: The default values for the options missing in the file.  If\n            a default is missing too, then the default in this class will be used.\n    Returns:\n        The configuration.\n    \"\"\"\ntry:\nwith open(path, \"rb\") as toml_file:\npyproject_toml = tomllib.load(toml_file)\nexcept FileNotFoundError:\nreturn cls(**defaults)\nexcept OSError as err:\n_logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\nreturn cls(**defaults)\ntry:\nconfig = pyproject_toml[\"tool\"][\"setuptools_betterproto\"]\nexcept KeyError:\nreturn cls(**defaults)\ndefault = cls(**defaults)\nknown_keys = frozenset(dataclasses.asdict(default).keys())\nconfig_keys = frozenset(config.keys())\nif unknown_keys := config_keys - known_keys:\n_logger.warning(\n\"WARNING: There are some configuration keys in pyproject.toml we don't \"\n\"know about and will be ignored: %s\",\n\", \".join(f\"'{k}'\" for k in unknown_keys),\n)\nattrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\nreturn dataclasses.replace(default, **attrs)\n</code></pre>"}]}
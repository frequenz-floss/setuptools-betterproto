{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Betterproto Setuptools plugin","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A modern <code>setuptools</code> plugin to generate Python files from proto files using <code>betterproto</code>.</p> <p>This plugin is based on <code>repo-config</code>'s <code>grpc_tools</code> plugin.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"#similar-projects","title":"Similar projects","text":"<ul> <li><code>setuptools-proto</code>: We didn't use this project because it seems a bit inactive and not widely used. It also seems to need some configuration as code, which we wanted to avoid.</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing to Betterproto Setuptools plugin","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>setuptools_betterproto</li> </ul>"},{"location":"reference/setuptools_betterproto/","title":"setuptools_betterproto","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto","title":"setuptools_betterproto","text":"<p>A modern setuptools plugin to generate Python files from proto files using betterproto.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto-classes","title":"Classes","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto","title":"setuptools_betterproto.CompileProto","text":"<p>             Bases: <code>Command</code></p> <p>Build the Python protobuf files.</p> Source code in <code>setuptools_betterproto/_command.py</code> <pre><code>class CompileProto(setuptools.Command):\n    \"\"\"Build the Python protobuf files.\"\"\"\n\n    proto_path: str\n    \"\"\"The path of the root directory containing the protobuf files.\"\"\"\n\n    proto_glob: str\n    \"\"\"The glob pattern to use to find the protobuf files.\"\"\"\n\n    include_paths: str\n    \"\"\"Comma-separated list of paths to include when compiling the protobuf files.\"\"\"\n\n    out_dir: str\n    \"\"\"The path of the root directory where the Python files will be generated.\"\"\"\n\n    description: str = \"compile protobuf files using betterproto\"\n    \"\"\"Description of the command.\"\"\"\n\n    user_options: list[tuple[str, str | None, str]] = [\n        (\n            \"proto-path=\",\n            None,\n            \"path of the root directory containing the protobuf files\",\n        ),\n        (\"proto-glob=\", None, \"glob pattern to use to find the protobuf files\"),\n        (\n            \"include-paths=\",\n            None,\n            \"comma-separated list of paths to include when compiling the protobuf files\",\n        ),\n        (\n            \"out-dir=\",\n            None,\n            \"path of the root directory where the Python files will be generated\",\n        ),\n    ]\n    \"\"\"Options of the command.\"\"\"\n\n    def initialize_options(self) -&gt; None:\n        \"\"\"Initialize options.\"\"\"\n        config = _config.ProtobufConfig.from_pyproject_toml()\n\n        self.proto_path = config.proto_path\n        self.proto_glob = config.proto_glob\n        self.include_paths = \",\".join(config.include_paths)\n        self.out_dir = config.out_dir\n\n    def finalize_options(self) -&gt; None:\n        \"\"\"Finalize options.\"\"\"\n\n    def _expand_paths(\n        self, proto_path: pathlib.Path, proto_glob: str\n    ) -&gt; Iterator[pathlib.Path]:\n        \"\"\"Expand the paths to the proto files.\"\"\"\n        return (p.relative_to(proto_path) for p in proto_path.rglob(proto_glob))\n\n    def run(self) -&gt; None:\n        \"\"\"Compile the Python protobuf files.\"\"\"\n        include_paths = list(map(pathlib.Path, self.include_paths.split(\",\")))\n        proto_path = pathlib.Path(self.proto_path)\n        proto_files = list(self._expand_paths(proto_path, self.proto_glob))\n\n        if not proto_files:\n            print(\n                f\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n                \"skipping compilation of proto files.\"\n            )\n            return\n\n        protoc_cmd = [\n            sys.executable,\n            \"-m\",\n            \"grpc_tools.protoc\",\n            *(f\"-I{p}\" for p in [self.proto_path, *include_paths]),\n            f\"--python_betterproto_out={self.out_dir}\",\n            *map(str, proto_files),\n        ]\n\n        print(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n        subprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto-attributes","title":"Attributes","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = (\n    \"compile protobuf files using betterproto\"\n)\n</code></pre> <p>Description of the command.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.include_paths","title":"include_paths  <code>instance-attribute</code>","text":"<pre><code>include_paths: str\n</code></pre> <p>Comma-separated list of paths to include when compiling the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.out_dir","title":"out_dir  <code>instance-attribute</code>","text":"<pre><code>out_dir: str\n</code></pre> <p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.proto_glob","title":"proto_glob  <code>instance-attribute</code>","text":"<pre><code>proto_glob: str\n</code></pre> <p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.proto_path","title":"proto_path  <code>instance-attribute</code>","text":"<pre><code>proto_path: str\n</code></pre> <p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.user_options","title":"user_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_options: list[tuple[str, str | None, str]] = [\n    (\n        \"proto-path=\",\n        None,\n        \"path of the root directory containing the protobuf files\",\n    ),\n    (\n        \"proto-glob=\",\n        None,\n        \"glob pattern to use to find the protobuf files\",\n    ),\n    (\n        \"include-paths=\",\n        None,\n        \"comma-separated list of paths to include when compiling the protobuf files\",\n    ),\n    (\n        \"out-dir=\",\n        None,\n        \"path of the root directory where the Python files will be generated\",\n    ),\n]\n</code></pre> <p>Options of the command.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto-functions","title":"Functions","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.finalize_options","title":"finalize_options","text":"<pre><code>finalize_options() -&gt; None\n</code></pre> <p>Finalize options.</p> Source code in <code>setuptools_betterproto/_command.py</code> <pre><code>def finalize_options(self) -&gt; None:\n    \"\"\"Finalize options.\"\"\"\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.initialize_options","title":"initialize_options","text":"<pre><code>initialize_options() -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>setuptools_betterproto/_command.py</code> <pre><code>def initialize_options(self) -&gt; None:\n    \"\"\"Initialize options.\"\"\"\n    config = _config.ProtobufConfig.from_pyproject_toml()\n\n    self.proto_path = config.proto_path\n    self.proto_glob = config.proto_glob\n    self.include_paths = \",\".join(config.include_paths)\n    self.out_dir = config.out_dir\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.CompileProto.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Compile the Python protobuf files.</p> Source code in <code>setuptools_betterproto/_command.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Compile the Python protobuf files.\"\"\"\n    include_paths = list(map(pathlib.Path, self.include_paths.split(\",\")))\n    proto_path = pathlib.Path(self.proto_path)\n    proto_files = list(self._expand_paths(proto_path, self.proto_glob))\n\n    if not proto_files:\n        print(\n            f\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n            \"skipping compilation of proto files.\"\n        )\n        return\n\n    protoc_cmd = [\n        sys.executable,\n        \"-m\",\n        \"grpc_tools.protoc\",\n        *(f\"-I{p}\" for p in [self.proto_path, *include_paths]),\n        f\"--python_betterproto_out={self.out_dir}\",\n        *map(str, proto_files),\n    ]\n\n    print(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n    subprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig","title":"setuptools_betterproto.ProtobufConfig  <code>dataclass</code>","text":"<p>A configuration for the protobuf files.</p> <p>The configuration can be loaded from the <code>pyproject.toml</code> file using the class method <code>from_pyproject_toml()</code>.</p> Source code in <code>setuptools_betterproto/_config.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ProtobufConfig:\n    \"\"\"A configuration for the protobuf files.\n\n    The configuration can be loaded from the `pyproject.toml` file using the class\n    method `from_pyproject_toml()`.\n    \"\"\"\n\n    proto_path: str = \".\"\n    \"\"\"The path of the root directory containing the protobuf files.\"\"\"\n\n    proto_glob: str = \"*.proto\"\n    \"\"\"The glob pattern to use to find the protobuf files.\"\"\"\n\n    include_paths: Sequence[str] = ()\n    \"\"\"The paths to add to the include path when compiling the protobuf files.\"\"\"\n\n    out_dir: str = \".\"\n    \"\"\"The path of the root directory where the Python files will be generated.\"\"\"\n\n    @classmethod\n    def from_pyproject_toml(\n        cls, path: str = \"pyproject.toml\", /, **defaults: Any\n    ) -&gt; Self:\n        \"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n\n        The options are read from the `[tool.frequenz-repo-config.protobuf]`\n        section of the `pyproject.toml` file.\n\n        Args:\n            path: The path to the `pyproject.toml` file.\n            **defaults: The default values for the options missing in the file.  If\n                a default is missing too, then the default in this class will be used.\n\n        Returns:\n            The configuration.\n        \"\"\"\n        try:\n            with open(path, \"rb\") as toml_file:\n                pyproject_toml = tomllib.load(toml_file)\n        except FileNotFoundError:\n            return cls(**defaults)\n        except OSError as err:\n            _logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\n            return cls(**defaults)\n\n        try:\n            config = pyproject_toml[\"tool\"][\"setuptools_betterproto\"]\n        except KeyError:\n            return cls(**defaults)\n\n        default = cls(**defaults)\n        known_keys = frozenset(dataclasses.asdict(default).keys())\n        config_keys = frozenset(config.keys())\n        if unknown_keys := config_keys - known_keys:\n            _logger.warning(\n                \"WARNING: There are some configuration keys in pyproject.toml we don't \"\n                \"know about and will be ignored: %s\",\n                \", \".join(f\"'{k}'\" for k in unknown_keys),\n            )\n\n        attrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\n        return dataclasses.replace(default, **attrs)\n</code></pre>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig-attributes","title":"Attributes","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.include_paths","title":"include_paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>include_paths: Sequence[str] = ()\n</code></pre> <p>The paths to add to the include path when compiling the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.out_dir","title":"out_dir  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>out_dir: str = '.'\n</code></pre> <p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.proto_glob","title":"proto_glob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proto_glob: str = '*.proto'\n</code></pre> <p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.proto_path","title":"proto_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proto_path: str = '.'\n</code></pre> <p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig-functions","title":"Functions","text":""},{"location":"reference/setuptools_betterproto/#setuptools_betterproto.ProtobufConfig.from_pyproject_toml","title":"from_pyproject_toml  <code>classmethod</code>","text":"<pre><code>from_pyproject_toml(\n    path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self\n</code></pre> <p>Create a new configuration by loading the options from a <code>pyproject.toml</code> file.</p> <p>The options are read from the <code>[tool.frequenz-repo-config.protobuf]</code> section of the <code>pyproject.toml</code> file.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to the <code>pyproject.toml</code> file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pyproject.toml'</code> </p> <code>**defaults</code> <p>The default values for the options missing in the file.  If a default is missing too, then the default in this class will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The configuration.</p> Source code in <code>setuptools_betterproto/_config.py</code> <pre><code>@classmethod\ndef from_pyproject_toml(\n    cls, path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self:\n    \"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n\n    The options are read from the `[tool.frequenz-repo-config.protobuf]`\n    section of the `pyproject.toml` file.\n\n    Args:\n        path: The path to the `pyproject.toml` file.\n        **defaults: The default values for the options missing in the file.  If\n            a default is missing too, then the default in this class will be used.\n\n    Returns:\n        The configuration.\n    \"\"\"\n    try:\n        with open(path, \"rb\") as toml_file:\n            pyproject_toml = tomllib.load(toml_file)\n    except FileNotFoundError:\n        return cls(**defaults)\n    except OSError as err:\n        _logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\n        return cls(**defaults)\n\n    try:\n        config = pyproject_toml[\"tool\"][\"setuptools_betterproto\"]\n    except KeyError:\n        return cls(**defaults)\n\n    default = cls(**defaults)\n    known_keys = frozenset(dataclasses.asdict(default).keys())\n    config_keys = frozenset(config.keys())\n    if unknown_keys := config_keys - known_keys:\n        _logger.warning(\n            \"WARNING: There are some configuration keys in pyproject.toml we don't \"\n            \"know about and will be ignored: %s\",\n            \", \".join(f\"'{k}'\" for k in unknown_keys),\n        )\n\n    attrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\n    return dataclasses.replace(default, **attrs)\n</code></pre>"}]}